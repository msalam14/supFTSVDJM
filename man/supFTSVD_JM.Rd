% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/high_dimensional_long_surv_jm.R
\name{supFTSVD_JM}
\alias{supFTSVD_JM}
\title{Supervised functional singular value decomposition}
\usage{
supFTSVD_JM(
  datlist,
  response = NULL,
  interval = NULL,
  r = 3,
  resolution = 100,
  CVPhi = FALSE,
  K = 5,
  cvT = 5,
  smooth = 1e-08,
  surv_time,
  censor_status,
  survX = NULL,
  mc_ss = 1000,
  maxiter = 20,
  epsilon = 1e-04,
  KInd = NULL,
  rsvd_seed = 100,
  conv_criteria = "par",
  scale = TRUE,
  constant_hazard = TRUE,
  change_points = NULL
)
}
\arguments{
\item{datlist}{a list with n elements, each is a matrix of dimension p+1
times m_i. The first row represents time points where measurements were
obtained. Next p rows represent the function values observed at the time
points}

\item{response}{a matrix of dimension n by q contains the design matrix for
supervision of the subject loadings}

\item{interval}{represents the domain of the function. The default is NULL.}

\item{r}{number of low-rank components involved in the assumed model}

\item{resolution}{grid size on which the singular functions will be estimated}

\item{CVPhi}{a logical scalar representing whether cross-validation (CV) will be
performed for determining the smoothness parameters involved with singular
functions}

\item{K}{number of folds for the CV step}

\item{cvT}{number of initial iterations at which CV will be performed}

\item{smooth}{Smoothing parameter for RKHS norm when CVPhi is FALSE. With
CVPhi=TRUE, a vector of numeric values for smoothness parameters for grid
search}

\item{surv_time}{a vector of N elements  represening observed survival times}

\item{censor_status}{a vector of censoring indicators (1 indicates censoring)}

\item{survX}{time-independent covariates specific to the survival sub-model}

\item{mc_ss}{Monte Carlo sample size for the E-step}

\item{maxiter}{Maximum number of iteration. Default: 20.}

\item{epsilon}{Convergence threshold for objective function value}

\item{KInd}{is a vector indices to construct the folds for CV. The default is
NULL that indicates that folds will be constructed randomly inside}

\item{rsvd_seed}{seed for random SVD (default is 100)}

\item{conv_criteria}{on which quantity the algorithm would be terminated (the
default is "par", indicating maximum difference in parameters will be used)}

\item{scale}{a logical indicating whether unit norm and scale for subject
loading components will be used (default is TRUE)}

\item{constant_hazard}{a logical indicting whether a constant hazard will be
used (default is TRUE). If FALSE, a piecewise constant hazard will be fitted}

\item{change_points}{the change_points to be used when a piecewise constant
hazard function is fitted. The default is NULL, indicating deciles from the
observed survival times will be used as change points.}
}
\value{
a list with following objects:
\itemize{
\item A.hat : a matrix of dimension N by K containing the values of
conditional means for subjects
\item B.hat : a matrix of dimension P by K representing the subject loadings
\item Phi.hat : a matrix of dimension resolution by r representing the
estimated singular functions
\item time : a vector of time points where Phi.hat values are estimated
\item ConU : a matrix of N by K, containing conditional mean obtained at the
final iteration
\item Lambda : a vector of r lambda values for weights (CP decomposition) of
low-rank components
\item Gamma : a matrix of q by r representing the estimated beta parameters
\item Xb=Xb : deterministic parts of the conditional means
\item r2_stat : goodness of fit statistics, R^2
\item Sigma2R : r estimated variance parameters involving with subject
loading models
\item Sigma2 : estimated tensor noise variance
\item cnvr_thresh : thresh of the convergence criterion from the fintal step
\item CoxPH_obj : estimated baselize hazard, cumulative hazard, estimated
parameters, and other quantities related to the survival sub-model
\item cnvrgnt : change of objective function value at different iterations
\item Scale : value of the argument Scale (necessary for other functions)
\item Constant_Hazard : value fo the Constant_Hazard argument (necessary fot
prediction)
}
}
\description{
This function performs low-rank decomposition of high-dimensional
multivariate function following the methodology proposed in Alam (2024+)
}
\examples{
# Number of subjects
n<-50

# feature dimension
pdim<-c(200)
# No of rank-1 components
r<-3
model_rank<-r

# Weight for components
lmd_val<-c(5.20,4.80,3.35)

# noise variance in tensor
Tau2<-c(0.1)

# Parameters for supervised component
Eta2<-c(1,1,1)

#diag(Eta2)<-c(1.85,2.50,1.3,1.60,1.25,3.5)
gam_par<-matrix(c(2.2,1.6,2.5,3.6,-1.50,2.6),ncol=3)
gam_par<-apply(gam_par,2,function(u){u/sqrt(sum(u^2))})

# Grid of Time points
nres<-101
Time<-seq(0,1,length.out=nres)

# Singular Function
PhiFunc<-list(function(x){(8+(6*x^8)-(3*x^2)-(4*x^3))/sqrt(45.61)},
              function(x){(10*x^2/exp(x^5))/(sqrt(10-10*exp(-2)))},
              function(x){sqrt(2)*sin(2.5*pi*x)})

PhiF<-sapply(1:r,function(k){PhiFunc[[k]](Time)})

# Feature loading
set.seed(pdim)
Bval<<-sapply(1:r, function(b){runif(pdim)})
bval<<-Bval*outer(rep(1,pdim),1/apply(Bval,2,norm,type="2"))

# controlling the signal ot noise ratio
cmp_var<-((lmd_val^2)*Eta2)
CmpV<-Reduce(`+`,lapply(1:r,function(k){cmp_var[k]*(outer(bval[,k],
                                                          PhiF[,k]))^2}))


# Survival parameters
alp_par<-matrix(c(3.50,2.60,-0.15,-0.20,0.15),ncol=1)
lmd<-0.10
## Subject-specific covariates # ADAS13
set.seed(n)
Vmat<<-cbind(round(runif(n),2),round(rbeta(n,2.5,1.5),2))
EAval<-Vmat\%*\%gam_par
miv_subE<-sapply(Eta2,function(u){rnorm(n,mean=0,sd=sqrt(u))})
ZetaSL<-EAval+miv_subE

# Training data set
# Survival data generation
seed_n<-4
set.seed(seed_n*24) # for both survival and longitudinal data
surv_time<-(-log(runif(n,0,1)))/(lmd*exp(as.numeric(cbind(Vmat,
                                                          ZetaSL)\%*\%(alp_par))))
summary(surv_time)
censor_time<-runif(n,0,5)
survT<-apply(cbind(surv_time,censor_time),1,min)
#summary(survT)
cenI<-apply(cbind(surv_time,censor_time),1,which.min)-1
cen_indx<-which(survT>1)
survT[cen_indx]<-1
cenI[cen_indx]<-1

# training m-omics data
m_i<-sample(5:10,n,replace = TRUE)
bl_time<-sapply(survT, function(u){runif(1,0,u)})
tr_obsTIME<-lapply(1:n, function(i){c(0,sort(runif(m_i[i]-2,0,
                                                   survT[i])),survT[i])})
gen_dataCFS<-omics_data_gen_surv(m_i = m_i,Zeta= ZetaSL,obsTIME = tr_obsTIME,
                                 Xi = bval,PsiF = PhiFunc,sing_val = lmd_val,
                                 Data_Var = Tau2,surv_time=survT)


fit_model<-supFTSVD_JM(datlist = gen_dataCFS$data,
                       response=Vmat, interval = c(0,1), r = model_rank,
                       resolution=50, CVPhi=FALSE, K=5, cvT=5,
                       smooth=0.001,
                       surv_time=survT,
                       censor_status=cenI,
                       maxiter=25, epsilon=1e-5,KInd=NULL,rsvd_seed=100,
                       conv_criteria = "cond_lik",
                       survX = Vmat,scale = TRUE,constant_hazard = TRUE)

save(fit_model,file = "data/fit_model.RData")
}
